/// <reference types="node" />
/// <reference types="node" />
import Stream from 'stream';
import type { ExecResult, InsertResult } from './connection';
import type { Logger } from './logger';
import { type DataFormat } from './data_formatter';
import { ResultSet } from './result';
import type { ClickHouseSettings } from './settings';
import type { InputJSON, InputJSONObjectEachRow } from './clickhouse_types';
export interface ClickHouseClientConfigOptions {
    /** A ClickHouse instance URL.
     * <br/> Default value: `http://localhost:8123`. */
    host?: string;
    /** The request timeout in milliseconds.
     * <br/> Default value: `30_000`. */
    request_timeout?: number;
    /** Maximum number of sockets to allow per host.
     * <br/> Default value: `Infinity`. */
    max_open_connections?: number;
    compression?: {
        /** `response: true` instructs ClickHouse server to respond with
         * compressed response body. <br/> Default: true. */
        response?: boolean;
        /** `request: true` enabled compression on the client request body.
         * <br/> Default: false. */
        request?: boolean;
    };
    /** The name of the user on whose behalf requests are made.
     * <br/> Default: 'default'. */
    username?: string;
    /** The user password. <br/> Default: ''. */
    password?: string;
    /** The name of the application using the nodejs client.
     * <br/> Default: empty. */
    application?: string;
    /** Database name to use. <br/> Default value: `default`. */
    database?: string;
    /** ClickHouse settings to apply to all requests. <br/> Default value: {} */
    clickhouse_settings?: ClickHouseSettings;
    log?: {
        /** A class to instantiate a custom logger implementation.
         * <br/> Default: {@link DefaultLogger} */
        LoggerClass?: new () => Logger;
    };
    tls?: BasicTLSOptions | MutualTLSOptions;
    session_id?: string;
    /** HTTP Keep-Alive related settings */
    keep_alive?: {
        /** Enable or disable HTTP Keep-Alive mechanism. <br/> Default: true */
        enabled?: boolean;
        /** How long to keep a particular open socket alive
         * on the client side (in milliseconds).
         * Should be less than the server setting
         * (see `keep_alive_timeout` in server's `config.xml`). <br/>
         * Currently, has no effect if {@link retry_on_expired_socket}
         * is unset or false. <br/> Default value: 2500
         * (based on the default ClickHouse server setting, which is 3000) */
        socket_ttl?: number;
        /** If the client detects a potentially expired socket based on the
         * {@link socket_ttl}, this socket will be immediately destroyed
         * before sending the request, and this request will be retried
         * with a new socket up to 3 times.
         * <br/> * Default: false (no retries) */
        retry_on_expired_socket?: boolean;
    };
}
interface BasicTLSOptions {
    ca_cert: Buffer;
}
interface MutualTLSOptions {
    ca_cert: Buffer;
    cert: Buffer;
    key: Buffer;
}
export interface BaseParams {
    /** ClickHouse settings that can be applied on query level. */
    clickhouse_settings?: ClickHouseSettings;
    /** Parameters for query binding. https://clickhouse.com/docs/en/interfaces/http/#cli-queries-with-parameters */
    query_params?: Record<string, unknown>;
    /** AbortSignal instance to cancel a request in progress. */
    abort_signal?: AbortSignal;
    /** A specific `query_id` that will be sent with this request.
     * If it is not set, a random identifier will be generated automatically by the client. */
    query_id?: string;
}
export interface QueryParams extends BaseParams {
    /** Statement to execute. */
    query: string;
    /** Format of the resulting dataset. */
    format?: DataFormat;
}
export interface ExecParams extends BaseParams {
    /** Statement to execute. */
    query: string;
}
export type CommandParams = ExecParams;
export interface CommandResult {
    query_id: string;
}
type InsertValues<T> = ReadonlyArray<T> | Stream.Readable | InputJSON<T> | InputJSONObjectEachRow<T>;
export interface InsertParams<T = unknown> extends BaseParams {
    /** Name of a table to insert into. */
    table: string;
    /** A dataset to insert. */
    values: InsertValues<T>;
    /** Format of the dataset to insert. */
    format?: DataFormat;
}
export declare class ClickHouseClient {
    private readonly config;
    private readonly connection;
    private readonly logger;
    constructor(config?: ClickHouseClientConfigOptions);
    private getBaseParams;
    /**
     * Used for most statements that can have a response, such as SELECT.
     * FORMAT clause should be specified separately via {@link QueryParams.format} (default is JSON)
     * Consider using {@link ClickHouseClient.insert} for data insertion,
     * or {@link ClickHouseClient.command} for DDLs.
     */
    query(params: QueryParams): Promise<ResultSet>;
    /**
     * It should be used for statements that do not have any output,
     * when the format clause is not applicable, or when you are not interested in the response at all.
     * Response stream is destroyed immediately as we do not expect useful information there.
     * Examples of such statements are DDLs or custom inserts.
     * If you are interested in the response data, consider using {@link ClickHouseClient.exec}
     */
    command(params: CommandParams): Promise<CommandResult>;
    /**
     * Similar to {@link ClickHouseClient.command}, but for the cases where the output is expected,
     * but format clause is not applicable. The caller of this method is expected to consume the stream,
     * otherwise, the request will eventually be timed out.
     */
    exec(params: ExecParams): Promise<ExecResult>;
    /**
     * The primary method for data insertion. It is recommended to avoid arrays in case of large inserts
     * to reduce application memory consumption and consider streaming for most of such use cases.
     * As the insert operation does not provide any output, the response stream is immediately destroyed.
     * In case of a custom insert operation, such as, for example, INSERT FROM SELECT,
     * consider using {@link ClickHouseClient.command}, passing the entire raw query there (including FORMAT clause).
     */
    insert<T>(params: InsertParams<T>): Promise<InsertResult>;
    /**
     * Health-check request. Can throw an error if the connection is refused.
     */
    ping(): Promise<boolean>;
    /**
     * Shuts down the underlying connection.
     * This method should ideally be called only once per application lifecycle,
     * for example, during the graceful shutdown phase.
     */
    close(): Promise<void>;
}
export declare function validateInsertValues<T>(values: InsertValues<T>, format: DataFormat): void;
/**
 * A function encodes an array or a stream of JSON objects to a format compatible with ClickHouse.
 * If values are provided as an array of JSON objects, the function encodes it in place.
 * If values are provided as a stream of JSON objects, the function sets up the encoding of each chunk.
 * If values are provided as a raw non-object stream, the function does nothing.
 *
 * @param values a set of values to send to ClickHouse.
 * @param format a format to encode value to.
 */
export declare function encodeValues<T>(values: InsertValues<T>, format: DataFormat): string | Stream.Readable;
export declare function createClient(config?: ClickHouseClientConfigOptions): ClickHouseClient;
export {};
