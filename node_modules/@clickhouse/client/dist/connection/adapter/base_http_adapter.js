"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseHttpAdapter = void 0;
const stream_1 = __importDefault(require("stream"));
const zlib_1 = __importDefault(require("zlib"));
const error_1 = require("../../error");
const http_search_params_1 = require("./http_search_params");
const transform_url_1 = require("./transform_url");
const utils_1 = require("../../utils");
const user_agent_1 = require("../../utils/user_agent");
const uuid = __importStar(require("uuid"));
function isSuccessfulResponse(statusCode) {
    return Boolean(statusCode && 200 <= statusCode && statusCode < 300);
}
function withHttpSettings(clickhouse_settings, compression) {
    return {
        ...(compression
            ? {
                enable_http_compression: 1,
            }
            : {}),
        ...clickhouse_settings,
    };
}
function decompressResponse(response) {
    const encoding = response.headers['content-encoding'];
    if (encoding === 'gzip') {
        return {
            response: stream_1.default.pipeline(response, zlib_1.default.createGunzip(), function pipelineCb(err) {
                if (err) {
                    console.error(err);
                }
            }),
        };
    }
    else if (encoding !== undefined) {
        return {
            error: new Error(`Unexpected encoding: ${encoding}`),
        };
    }
    return { response };
}
function isDecompressionError(result) {
    return result.error !== undefined;
}
const expiredSocketMessage = 'expired socket';
class BaseHttpAdapter {
    constructor(config, logger, agent) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: logger
        });
        Object.defineProperty(this, "agent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: agent
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "retry_expired_sockets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "known_sockets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new WeakMap()
        });
        this.headers = this.buildDefaultHeaders(config.username, config.password);
        this.retry_expired_sockets =
            this.config.keep_alive.enabled &&
                this.config.keep_alive.retry_on_expired_socket;
    }
    buildDefaultHeaders(username, password) {
        return {
            Authorization: `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`,
            'User-Agent': (0, user_agent_1.getUserAgent)(this.config.application_id),
        };
    }
    async request(params, retryCount = 0) {
        try {
            return await this._request(params);
        }
        catch (e) {
            if (e instanceof Error && e.message === expiredSocketMessage) {
                if (this.retry_expired_sockets && retryCount < 3) {
                    this.logger.trace({
                        module: 'Connection',
                        message: `Keep-Alive socket is expired, retrying with a new one, retries so far: ${retryCount}`,
                    });
                    return await this.request(params, retryCount + 1);
                }
                else {
                    throw new Error(`Socket hang up after ${retryCount} retries`);
                }
            }
            throw e;
        }
    }
    async _request(params) {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            const request = this.createClientRequest(params, params.abort_signal);
            function onError(err) {
                removeRequestListeners();
                reject(err);
            }
            const onResponse = async (_response) => {
                this.logResponse(request, params, _response, start);
                const decompressionResult = decompressResponse(_response);
                if (isDecompressionError(decompressionResult)) {
                    return reject(decompressionResult.error);
                }
                if (isSuccessfulResponse(_response.statusCode)) {
                    return resolve(decompressionResult.response);
                }
                else {
                    reject((0, error_1.parseError)(await (0, utils_1.getAsText)(decompressionResult.response)));
                }
            };
            function onAbort() {
                // Prefer 'abort' event since it always triggered unlike 'error' and 'close'
                // see the full sequence of events https://nodejs.org/api/http.html#httprequesturl-options-callback
                removeRequestListeners();
                request.once('error', function () {
                    /**
                     * catch "Error: ECONNRESET" error which shouldn't be reported to users.
                     * see the full sequence of events https://nodejs.org/api/http.html#httprequesturl-options-callback
                     * */
                });
                reject(new Error('The request was aborted.'));
            }
            function onClose() {
                // Adapter uses 'close' event to clean up listeners after the successful response.
                // It's necessary in order to handle 'abort' and 'timeout' events while response is streamed.
                // It's always the last event, according to https://nodejs.org/docs/latest-v14.x/api/http.html#http_http_request_url_options_callback
                removeRequestListeners();
            }
            function pipeStream() {
                // if request.end() was called due to no data to send
                if (request.writableEnded) {
                    return;
                }
                const bodyStream = (0, utils_1.isStream)(params.body)
                    ? params.body
                    : stream_1.default.Readable.from([params.body]);
                const callback = (err) => {
                    if (err) {
                        removeRequestListeners();
                        reject(err);
                    }
                };
                if (params.compress_request) {
                    stream_1.default.pipeline(bodyStream, zlib_1.default.createGzip(), request, callback);
                }
                else {
                    stream_1.default.pipeline(bodyStream, request, callback);
                }
            }
            const onSocket = (socket) => {
                if (this.retry_expired_sockets) {
                    // if socket is reused
                    const socketInfo = this.known_sockets.get(socket);
                    if (socketInfo !== undefined) {
                        this.logger.trace({
                            module: 'Connection',
                            message: `Reused socket ${socketInfo.id}`,
                        });
                        // if a socket was reused at an unfortunate time,
                        // and is likely about to expire
                        const isPossiblyExpired = Date.now() - socketInfo.last_used_time >
                            this.config.keep_alive.socket_ttl;
                        if (isPossiblyExpired) {
                            this.logger.trace({
                                module: 'Connection',
                                message: 'Socket should be expired - terminate it',
                            });
                            this.known_sockets.delete(socket);
                            socket.destroy(); // immediately terminate the connection
                            request.destroy();
                            reject(new Error(expiredSocketMessage));
                        }
                        else {
                            this.logger.trace({
                                module: 'Connection',
                                message: `Socket ${socketInfo.id} is safe to be reused`,
                            });
                            this.known_sockets.set(socket, {
                                id: socketInfo.id,
                                last_used_time: Date.now(),
                            });
                            pipeStream();
                        }
                    }
                    else {
                        const socketId = uuid.v4();
                        this.logger.trace({
                            module: 'Connection',
                            message: `Using a new socket ${socketId}`,
                        });
                        this.known_sockets.set(socket, {
                            id: socketId,
                            last_used_time: Date.now(),
                        });
                        pipeStream();
                    }
                }
                else {
                    // no need to track the reused sockets;
                    // keep alive is disabled or retry mechanism is not enabled
                    pipeStream();
                }
                // this is for request timeout only.
                // The socket won't be actually destroyed,
                // and it will be returned to the pool.
                // TODO: investigate if can actually remove the idle sockets properly
                socket.setTimeout(this.config.request_timeout, onTimeout);
            };
            function onTimeout() {
                removeRequestListeners();
                request.destroy();
                reject(new Error('Timeout error'));
            }
            function removeRequestListeners() {
                if (request.socket !== null) {
                    request.socket.setTimeout(0); // reset previously set timeout
                    request.socket.removeListener('timeout', onTimeout);
                }
                request.removeListener('socket', onSocket);
                request.removeListener('response', onResponse);
                request.removeListener('error', onError);
                request.removeListener('close', onClose);
                if (params.abort_signal !== undefined) {
                    request.removeListener('abort', onAbort);
                }
            }
            request.on('socket', onSocket);
            request.on('response', onResponse);
            request.on('error', onError);
            request.on('close', onClose);
            if (params.abort_signal !== undefined) {
                params.abort_signal.addEventListener('abort', onAbort, { once: true });
            }
            if (!params.body)
                return request.end();
        });
    }
    async ping() {
        // TODO add status code check
        const stream = await this.request({
            method: 'GET',
            url: (0, transform_url_1.transformUrl)({ url: this.config.url, pathname: '/ping' }),
        });
        stream.destroy();
        return true;
    }
    async query(params) {
        const query_id = this.getQueryId(params);
        const clickhouse_settings = withHttpSettings(params.clickhouse_settings, this.config.compression.decompress_response);
        const searchParams = (0, http_search_params_1.toSearchParams)({
            database: this.config.database,
            clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            query_id,
        });
        const stream = await this.request({
            method: 'POST',
            url: (0, transform_url_1.transformUrl)({ url: this.config.url, pathname: '/', searchParams }),
            body: params.query,
            abort_signal: params.abort_signal,
            decompress_response: clickhouse_settings.enable_http_compression === 1,
        });
        return {
            stream,
            query_id,
        };
    }
    async exec(params) {
        const query_id = this.getQueryId(params);
        const searchParams = (0, http_search_params_1.toSearchParams)({
            database: this.config.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            query_id,
        });
        const stream = await this.request({
            method: 'POST',
            url: (0, transform_url_1.transformUrl)({ url: this.config.url, pathname: '/', searchParams }),
            body: params.query,
            abort_signal: params.abort_signal,
        });
        return {
            stream,
            query_id,
        };
    }
    async insert(params) {
        const query_id = this.getQueryId(params);
        const searchParams = (0, http_search_params_1.toSearchParams)({
            database: this.config.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            query: params.query,
            session_id: params.session_id,
            query_id,
        });
        const stream = await this.request({
            method: 'POST',
            url: (0, transform_url_1.transformUrl)({ url: this.config.url, pathname: '/', searchParams }),
            body: params.values,
            abort_signal: params.abort_signal,
            compress_request: this.config.compression.compress_request,
        });
        stream.destroy();
        return { query_id };
    }
    async close() {
        if (this.agent !== undefined && this.agent.destroy !== undefined) {
            this.agent.destroy();
        }
    }
    getQueryId(params) {
        return params.query_id || uuid.v4();
    }
    logResponse(request, params, response, startTimestamp) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { authorization, host, ...headers } = request.getHeaders();
        const duration = Date.now() - startTimestamp;
        this.logger.debug({
            module: 'Connection',
            message: 'Got a response from ClickHouse',
            args: {
                request_method: params.method,
                request_path: params.url.pathname,
                request_params: params.url.search,
                request_headers: headers,
                response_status: response.statusCode,
                response_headers: response.headers,
                response_time_ms: duration,
            },
        });
    }
    getHeaders(params) {
        return {
            ...this.headers,
            ...(params.decompress_response ? { 'Accept-Encoding': 'gzip' } : {}),
            ...(params.compress_request ? { 'Content-Encoding': 'gzip' } : {}),
        };
    }
}
exports.BaseHttpAdapter = BaseHttpAdapter;
//# sourceMappingURL=base_http_adapter.js.map